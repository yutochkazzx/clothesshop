# Полное построчное объяснение всего проекта Django-магазина

Ниже разобрана **каждая строка** кода во всех важных файлах: зачем она нужна и что делает. Файлы идут в логическом порядке.

---

# 1. manage.py

Точка входа для команд Django (`runserver`, `migrate`, `createsuperuser` и т.д.).

| Стр. | Код | Объяснение |
|------|-----|------------|
| 1 | `#!/usr/bin/env python` | Шебанг: при запуске файла напрямую система использует Python из окружения. На Windows часто не используется. |
| 2 | `"""Django's command-line utility..."""` | Строка документации модуля (docstring). На выполнение не влияет. |
| 3 | `import os` | Подключение модуля для работы с окружением и путями (например `os.environ`). |
| 4 | `import sys` | Подключение модуля с аргументами командной строки (`sys.argv` — список вроде `['manage.py', 'runserver']`). |
| 7 | `def main():` | Объявление функции `main`. |
| 9 | `os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'main.settings')` | Устанавливает переменную окружения `DJANGO_SETTINGS_MODULE` в `'main.settings'`, **только если** она ещё не задана. Так Django понимает, откуда брать настройки (файл `main/settings.py`). |
| 10 | `try:` | Начало блока перехвата ошибок. |
| 11 | `from django.core.management import execute_from_command_line` | Импорт функции Django, которая разбирает команду из `sys.argv` и выполняет её (runserver, migrate и т.д.). |
| 12 | `except ImportError as exc:` | Если импорт не удался (Django не установлен или не в PATH), перехватываем ошибку. |
| 13–16 | Текст в `raise ImportError(...)` | Сообщение пользователю: возможно, забыли активировать виртуальное окружение или установить Django. |
| 17 | `) from exc` | Цепочка исключений: новое исключение связано с исходным (удобно при отладке). |
| 18 | `execute_from_command_line(sys.argv)` | Передаём Django аргументы командной строки; Django выполняет нужную команду. |
| 20 | `if __name__ == '__main__':` | Условие «запущен ли этот файл напрямую» (а не импортирован). При `python manage.py runserver` это True. |
| 21 | `main()` | Вызов функции `main()` — выполняется только при прямом запуске файла. |

---

# 2. main/settings.py — настройки проекта

| Стр. | Код | Объяснение |
|------|-----|------------|
| 1–12 | Комментарии и docstring | Описание файла и ссылки на документацию. На выполнение не влияют. |
| 14 | `from pathlib import Path` | Класс для кроссплатформенной работы с путями к файлам. |
| 17 | `BASE_DIR = Path(__file__).resolve().parent.parent` | **Корень проекта.** `__file__` — путь к этому файлу (settings.py). `.resolve()` — абсолютный путь. `.parent` — папка `main`, ещё `.parent` — папка с `manage.py`. Нужен для путей к БД, медиа, статике. |
| 24 | `SECRET_KEY = '...'` | Секретный ключ для криптографии (подписи сессий, паролей и т.д.). В продакшене должен быть свой и не попадать в репозиторий. |
| 27 | `DEBUG = True` | Режим отладки: при ошибке показывается подробная страница. На продакшене обязательно `False`. |
| 29 | `ALLOWED_HOSTS = []` | Список разрешённых имён хоста для запросов. Пустой при DEBUG допускает любой хост (в т.ч. 127.0.0.1). |
| 35–43 | `INSTALLED_APPS = [...]` | Список приложений Django. `django.contrib.*` — встроенные (админка, авторизация, сессии, статика). `shop` и `cart` — твои приложения. Django подключает их модели, шаблоны, URL. |
| 46–54 | `MIDDLEWARE = [...]` | Цепочка промежуточных слоёв. Каждый запрос и ответ проходит через них по порядку: безопасность, сессии, CSRF, авторизация, сообщения, защита от кликджекинга. |
| 56 | `ROOT_URLCONF = 'main.urls'` | Главный файл маршрутов: Django ищет переменную `urlpatterns` в модуле `main.urls`. |
| 58–71 | `TEMPLATES = [...]` | Настройки шаблонов. `BACKEND` — движок Django. `DIRS: []` — доп. папки с шаблонами. `APP_DIRS: True` — искать шаблоны в папке `templates` каждого приложения из `INSTALLED_APPS`. `context_processors` — функции, которые добавляют переменные **во все** шаблоны (request, user, messages, cart_count). |
| 66 | `'cart.context_processors.cart_count'` | Твой контекст-процессор: на каждый запрос добавляет в контекст шаблона переменную `cart_count` (число товаров в корзине). |
| 73 | `WSGI_APPLICATION = 'main.wsgi.application'` | Точка входа WSGI для деплоя (gunicorn, uWSGI и т.д.). |
| 79–84 | `DATABASES = {...}` | Настройки БД. Движок SQLite, файл базы — `db.sqlite3` в корне проекта (в `BASE_DIR`). |
| 89–102 | `AUTH_PASSWORD_VALIDATORS` | Правила проверки паролей при смене/создании (сложность, похожесть на имя и т.д.). |
| 108 | `LANGUAGE_CODE = 'en-us'` | Язык интерфейса Django по умолчанию. |
| 110 | `TIME_ZONE = 'UTC'` | Часовой пояс по умолчанию. |
| 112 | `USE_I18N = True` | Включена интернационализация (переводы). |
| 114 | `USE_TZ = True` | Дата/время в БД хранятся с учётом часовых поясов. |
| 120 | `STATIC_URL = 'static/'` | URL-префикс для статических файлов (CSS, JS). Ссылки вида `/static/shop/main.css`. |
| 123–124 | `MEDIA_URL` / `MEDIA_ROOT` | URL и папка для загруженных файлов (фото товаров). Запросы к `/media/...` отдаются из папки `media/` в корне проекта. |
| 125 | `CART_SESSION_ID = 'cart'` | Ключ в сессии, под которым хранится корзина. Используется в приложении `cart`. |

---

# 3. main/urls.py — главные маршруты

| Стр. | Код | Объяснение |
|------|-----|------------|
| 1 | `from django.conf import settings` | Импорт объекта настроек (нужен для `settings.DEBUG` и др.). |
| 2 | `from django.conf.urls.static import static` | Функция, которая в режиме DEBUG добавляет маршруты для раздачи файлов из папки (медиа/статика). |
| 3 | `from django.contrib import admin` | Подключение админки Django. |
| 4 | `from django.urls import path, include` | `path` — одна запись маршрута (путь + view). `include` — подключение списка маршрутов из другого приложения. |
| 6–10 | `urlpatterns = [...]` | Список маршрутов. Django по порядку сверяет URL запроса с каждым `path`. |
| 7 | `path('admin/', admin.site.urls)` | Все адреса, начинающиеся с `admin/`, обрабатывает встроенная админка Django. |
| 8 | `path('', include('shop.urls', namespace='main'))` | Пустой путь и все остальные (кроме уже совпавших) передаются в `shop.urls`. Там уже свои правила. `namespace='main'` — в шаблонах пишем `main:product_list`, чтобы не путать с другими приложениями. |
| 9 | `path('cart/', include('cart.urls'))` | Все адреса, начинающиеся с `cart/`, обрабатываются приложением `cart` (файл `cart/urls.py`). Например `/cart/`, `/cart/add/5/`. |
| 11 | `if settings.DEBUG:` | Только в режиме отладки. |
| 12 | `urlpatterns += static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT)` | К списку маршрутов добавляются правила: запросы к URL из `MEDIA_URL` (например `/media/...`) отдают файлы из папки `MEDIA_ROOT`. Так в разработке показываются загруженные фото товаров. |

---

# 4. shop/models.py — модели (таблицы БД)

| Стр. | Код | Объяснение |
|------|-----|------------|
| 1 | `from django.db import models` | Базовый класс моделей и типы полей (CharField, IntegerField и т.д.). |
| 3 | `class Category(models.Model):` | Модель «Категория». Наследование от `Model` даёт связь с таблицей в БД и ORM (objects.all(), filter() и т.д.). |
| 4 | `name = models.CharField(max_length=100, db_index=True)` | Поле «название»: строка до 100 символов. `db_index=True` — в БД создаётся индекс, быстрее поиск и сортировка. |
| 6 | `slug = models.SlugField(max_length=100, unique=True)` | Короткое имя для URL (латиница, цифры, дефис). Должно быть уникальным — по нему строятся ссылки вида `/elektronika/`. |
| 8–11 | `class Meta:` / `ordering` / `verbose_name` | Метаданные модели. `ordering = ('name',)` — по умолчанию выборки сортируются по имени. `verbose_name` — как модель называется в админке (единственное и множественное число). |
| 13–14 | `def __str__(self):` / `return self.name` | Строковое представление объекта: в админке и в отладочном выводе категория показывается по имени. |
| 17–24 | `SIZE_CHOICES = (...)` | Кортеж пар (значение в БД, подпись для человека). Используется в поле `size` модели Product. |
| 25 | `class Product(models.Model):` | Модель «Товар». |
| 26 | `category = models.ForeignKey(Category, ...)` | Связь «много товаров — одна категория». В БД хранится id категории. `on_delete=CASCADE` — при удалении категории удаляются и её товары. |
| 27–28 | `name` / `slug` | Название и slug товара (для URL страницы товара). |
| 29 | `image = models.ImageField(upload_to='products/%Y/%m/%d', blank=True)` | Фото. Загружаются в подпапки по дате (год/месяц/день). `blank=True` — поле может быть пустым. |
| 30 | `description = models.TextField(blank=True)` | Описание товара, может быть пустым. |
| 31 | `price = models.DecimalField(max_digits=10, decimal_places=2)` | Цена: до 10 цифр всего, 2 знака после запятой. Удобно для денег и скидок. |
| 33 | `available = models.BooleanField(default=True)` | Есть ли товар в продаже. По умолчанию да. |
| 34 | `createddate = models.DateField(auto_now_add=True)` | Дата создания записи; выставляется при первом сохранении. |
| 35 | `updated = models.DateTimeField(auto_now=True)` | Дата/время последнего обновления; обновляется при каждом save(). |
| 36 | `size = models.CharField(..., choices=SIZE_CHOICES, default='M')` | Размер из списка SIZE_CHOICES; по умолчанию M. |
| 37 | `discount_percentage = models.PositiveSmallIntegerField(...)` | Процент скидки (целое число от 0). |
| 41 | `@property` | Декоратор: метод ниже будет доступен как атрибут (без скобок), только для чтения. |
| 42–46 | `def discounted_price(self):` | Считает цену со скидкой. Если скидка > 0, возвращает цену × (1 − скидка/100), иначе обычную цену. |
| 50–51 | `class Meta:` / `ordering = ('name',)` | Сортировка товаров по умолчанию по имени. |
| 52–53 | `def __str__(self):` / `return self.name` | В админке и в отладке товар показывается по имени. |

---

# 5. shop/views.py — логика страниц магазина

| Стр. | Код | Объяснение |
|------|-----|------------|
| 1 | `from django.shortcuts import render, get_object_or_404` | `render` — отрисовать шаблон с контекстом и вернуть HTTP-ответ. `get_object_or_404` — найти объект в БД или вернуть страницу 404. |
| 2 | `from .models import Category, Product` | Импорт моделей из этого приложения (shop). |
| 4 | `def product_list(request, category_slug=None):` | Функция списка товаров. `request` — объект запроса (Django передаёт сам). `category_slug` — slug категории из URL или None (главная). |
| 5 | `categories = Category.objects.all()` | Запрос в БД: все категории. Нужны для меню в шапке. |
| 6 | `products = Product.objects.filter(available=True).order_by('-createddate')` | Все доступные товары, сортировка по дате создания (новые первые). `-` означает по убыванию. |
| 8 | `category = None` | Пока не выбрана категория. |
| 9 | `if category_slug:` | Если в URL был slug категории (например пользователь открыл `/elektronika/`). |
| 10 | `category = get_object_or_404(Category, slug=category_slug)` | Найти категорию с таким slug. Если нет — Django вернёт ответ 404. |
| 11 | `products = products.filter(category=category)` | Оставить только товары этой категории. |
| 13–14 | `return render(request, 'main/product/list.html', {...})` | Отрисовать шаблон `list.html` (путь от папки `templates` приложения shop). Третий аргумент — словарь контекста: все эти переменные доступны в шаблоне по имени. |
| 16 | `def product_detail(request, id, slug):` | Функция страницы одного товара. `id` и `slug` приходят из URL (из shop/urls.py). |
| 17 | `product = get_object_or_404(Product, id=id, slug=slug, available=True)` | Найти товар с таким id и slug, доступный. Иначе 404. |
| 18–19 | `suggestedproducts = Product.objects.filter(...).exclude(...)[:4]` | Товары той же категории, доступные, кроме текущего; взять первые 4. |
| 20–22 | `return render(request, 'main/product/details.html', {...})` | Отрисовать шаблон страницы товара с контекстом `product` и `suggestedproducts`. |

---

# 6. shop/urls.py — маршруты приложения shop

| Стр. | Код | Объяснение |
|------|-----|------------|
| 1 | `from django.urls import path` | Функция для объявления одного маршрута. |
| 2 | `from . import views` | Импорт модуля views из этого приложения (функции product_list, product_detail). |
| 4 | `app_name = 'main'` | Имя приложения в URL. В шаблонах пишем `main:product_list`, чтобы однозначно указать этот маршрут. |
| 5–10 | `urlpatterns = [...]` | Список маршрутов. Проверяются после того, как main/urls.py «отрезал» префикс (здесь префикса нет, путь приходит как есть). |
| 6 | `path('', views.product_list, name='product_list')` | Пустой путь (главная страница) → вызывается `product_list`. Имя маршрута — `product_list` (для `{% url 'main:product_list' %}`). |
| 7 | `path('<slug:category_slug>/', views.product_list, name='product_list_bycat')` | Один сегмент пути (например `elektronika`) → та же функция, но с аргументом `category_slug='elektronika'`. Имя — `product_list_bycat`. |
| 8 | `path('<int:id>/<slug:slug>/', views.product_detail, name='product_detail')` | Два сегмента: целое число (id товара) и slug (например `5/telefon`) → вызывается `product_detail(request, id=5, slug='telefon')`. |

---

# 7. shop/admin.py — настройка админки

| Стр. | Код | Объяснение |
|------|-----|------------|
| 1–2 | Импорты | Админка Django и модели Category, Product. |
| 4 | `@admin.register(Category)` | Регистрирует модель Category в админке: в списке приложений появится «Категории». |
| 5–7 | `class CategoryAdmin` / `list_display` / `prepopulated_fields` | В списке категорий показывать колонки `name` и `slug`. Поле `slug` автоматически подставляется из `name` при вводе. |
| 9–14 | `@admin.register(Product)` / `ProductAdmin` | То же для товаров: колонки в списке, фильтры сбоку, `list_editable` — цену и доступность можно менять прямо в списке, slug заполняется из названия. |

---

# 8. cart/cart.py — класс корзины (сессия)

Корзина хранится в `request.session` под ключом `CART_SESSION_ID`. Структура: `{product_id: {'quantity': N, 'price': строка}}`.

| Стр. | Код | Объяснение |
|------|-----|------------|
| 1 | `from decimal import Decimal` | Точная работа с десятичными числами (для денег). |
| 2–3 | Импорты | Настройки (CART_SESSION_ID) и модель Product. |
| 5 | `class Cart(object):` | Класс корзины. Принимает request и работает с его сессией. |
| 6 | `def __init__(self, request):` | Конструктор: вызывается при создании Cart(request). |
| 7 | `self.session = request.session` | Сохраняем ссылку на объект сессии (словарь, хранящийся на сервере, ключ у пользователя в cookie). |
| 8 | `cart = self.session.get(settings.CART_SESSION_ID)` | Достаём из сессии данные корзины по ключу `'cart'`. Если ключа нет — вернётся None. |
| 9–10 | `if not cart:` / `cart = self.session[...] = {}` | Если корзины ещё не было — создаём пустой словарь и записываем его в сессию. |
| 11 | `self.cart = cart` | Сохраняем ссылку на этот словарь в объекте Cart. |
| 13 | `def add(self, product, quantity=1, update_quantity=False):` | Добавить товар. `update_quantity=True` — заменить количество, иначе прибавить к текущему. |
| 14 | `product_id = str(product.id)` | Ключи в словаре сессии — строки (удобно для JSON и совместимости). |
| 15 | `if product_id not in self.cart:` | Если этого товара ещё нет в корзине. |
| 16 | `price = getattr(product, 'discounted_price', product.price)` | Берём цену со скидкой, если у модели есть свойство discounted_price, иначе обычную цену. |
| 17–18 | `self.cart[product_id] = {'quantity': 0, 'price': str(price)}` | Создаём запись: количество 0, цена сохранена как строка (для сериализации в сессии). |
| 19 | `if update_quantity:` | Режим «обновить количество». |
| 20 | `self.cart[product_id]['quantity'] = quantity` | Записываем новое количество. |
| 21–22 | `else:` / `self.cart[product_id]['quantity'] += quantity` | Иначе прибавляем переданное количество к текущему. |
| 23 | `self.save()` | Сохраняем изменения в сессию. |
| 25–27 | `def save(self):` | Записываем словарь корзины обратно в сессию и помечаем сессию как изменённую (чтобы Django сохранил её на сервере). |
| 29–34 | `def remove(self, product):` | Удалить товар из корзины: удаляем ключ product_id из словаря и сохраняем сессию. |
| 36 | `def __iter__(self):` | Делает объект итерируемым: в шаблоне можно писать `{% for item in cart %}`. |
| 37 | `product_ids = self.cart.keys()` | Список id товаров в корзине (строки). |
| 38 | `products = Product.objects.filter(id__in=product_ids)` | Один запрос в БД: все эти товары. |
| 39 | `cart = self.cart.copy()` | Копия словаря, чтобы не менять исходные данные при добавлении полей. |
| 40–41 | Цикл по products | К каждой записи в копии (по id товара) добавляем объект `product` из БД. |
| 42–45 | Цикл по cart.values() | Для каждой позиции переводим цену в Decimal, считаем total_price (цена × количество), отдаём item через yield. В шаблоне у item есть product, quantity, price, total_price. |
| 47–48 | `def __len__(self):` | Возвращает общее количество штук в корзине (сумма quantity). Нужно для отображения «Корзина (5)». |
| 50–51 | `def get_total_price(self):` | Сумма по всем позициям: цена × количество. Возвращает Decimal. |
| 53–55 | `def clear(self):` | Очистить корзину: удалить ключ из сессии и пометить сессию изменённой. |

---

# 9. cart/views.py — страницы и действия корзины

| Стр. | Код | Объяснение |
|------|-----|------------|
| 1–4 | Импорты | render, redirect, get_object_or_404; декоратор require_POST; модель Product; класс Cart. |
| 7–9 | `def cart_detail(request):` | Страница корзины. Создаём объект Cart(request), отдаём шаблон `cart/cart.html` с переменной `cart`. |
| 11 | `@require_POST` | Следующая функция принимает только POST-запросы. GET на этот URL вернёт 405. Защита от случайного добавления по ссылке. |
| 12 | `def cart_add(request, product_id):` | Добавить в корзину. `product_id` приходит из URL (например `/cart/add/5/`). |
| 14 | `product = get_object_or_404(Product, id=product_id, available=True)` | Найти товар по id, доступный. Иначе 404. |
| 15 | `cart = Cart(request)` | Объект корзины для этого пользователя (сессии). |
| 16 | `quantity = int(request.POST.get('quantity', 1))` | Количество из формы (поле name="quantity"). По умолчанию 1. |
| 17–18 | Проверка quantity | Если передали 0 или меньше — ставим 1. |
| 19 | `cart.add(product, quantity=quantity)` | Добавляем товар в корзину с указанным количеством. |
| 20 | `next_url = request.POST.get('next', request.META.get('HTTP_REFERER', '/'))` | Куда вернуть пользователя после добавления: из скрытого поля `next` или с какой страницы пришёл (Referer), иначе главная. |
| 21 | `return redirect(next_url or '/')` | Редирект на полученный URL. |
| 24–29 | `cart_remove` | Только POST. Найти товар, корзину, удалить товар из корзины, редирект на страницу корзины. |
| 32–41 | `cart_update` | Только POST. Изменить количество: если 0 или меньше — удалить позицию, иначе обновить количество через cart.add(..., update_quantity=True). Редирект на страницу корзины. |

---

# 10. cart/urls.py — маршруты корзины

Подключены в main/urls как `path('cart/', include('cart.urls'))`, поэтому все пути ниже имеют префикс `/cart/`.

| Стр. | Код | Объяснение |
|------|-----|------------|
| 4 | `path('', views.cart_detail, name='cart_detail')` | Путь `/cart/` (пустая строка после префикса) → страница корзины. Имя для шаблонов: `cart_detail`. |
| 5 | `path('add/<int:product_id>/', views.cart_add, name='cart_add')` | `/cart/add/5/` → cart_add с product_id=5. Имя: `cart_add`. |
| 6 | `path('remove/<int:product_id>/', ...)` | Удаление из корзины. Имя: `cart_remove`. |
| 7 | `path('update/<int:product_id>/', ...)` | Изменение количества. Имя: `cart_update`. |

---

# 11. cart/context_processors.py — переменная cart_count в шаблонах

| Стр. | Код | Объяснение |
|------|-----|------------|
| 1 | `from django.conf import settings` | Нужен settings.CART_SESSION_ID. |
| 4 | `def cart_count(request):` | Функция вызывается Django при отрисовке **каждого** шаблона. Принимает request. |
| 6 | `cart_data = request.session.get(settings.CART_SESSION_ID, {})` | Достаём корзину из сессии. Если нет — пустой словарь. |
| 7–8 | Проверка типа | Если по какой-то причине в сессии не словарь — считаем корзину пустой. |
| 9 | `count = sum(item.get('quantity', 0) for item in cart_data.values())` | Суммируем количество по всем позициям. Без запросов к БД. |
| 10 | `return {'cart_count': count}` | Словарь добавляется в контекст шаблона — во всех страницах доступна переменная `cart_count`. |

---

# 12. Шаблон base.html (main/base.html)

Общая обёртка: шапка, место для контента, подвал. Остальные страницы расширяют этот шаблон и подставляют свой контент в блоки.

| Стр. | Код | Объяснение |
|------|-----|------------|
| 1 | `{% load static %}` | Подключает тег `{% static 'путь' %}` для ссылок на CSS/JS из папки static. |
| 2–6 | DOCTYPE, html, head, meta | Стандартный HTML: тип документа, язык, кодировка, viewport для мобильных. |
| 7 | `<title>{% block title %}  {% endblock title %}</title>` | Заголовок вкладки. Дочерние шаблоны переопределяют блок `title` своим текстом. |
| 8–147 | `<style>...</style>` | CSS: переменные цветов (:root), стили для body, шапки, навигации, основного блока, подвала, карточек товаров, страницы товара, корзины в шапке, таблицы корзины, кнопки «В корзину». Это обычный CSS, не логика Django. |
| 151–156 | Шапка: логотип и корзина | Ссылка «Магазин» на главную (`{% url 'main:product_list' %}`). Блок с ссылкой на корзину: `{% url 'cart_detail' %}` — URL страницы корзины. Текст «Корзина (N)», если `cart_count` передан контекст-процессором. |
| 158–172 | Меню категорий | Список: «Все товары» (активно, если переменная `category` пустая) и цикл по `categories`. Для каждой категории ссылка на список по категории (`main:product_list_bycat` с аргументом `category_slug=cat.slug`), класс `active`, если это текущая категория. `{{ cat.name }}` — название из БД. |
| 176–178 | Основной контент | `{% block content %}{% endblock content %}` — сюда дочерние шаблоны подставляют свой HTML. |
| 180–184 | Подвал и закрытие тегов | Текст «© Магазин», закрытие body и html. |

---

# 13. Шаблон list.html (список товаров)

| Стр. | Код | Объяснение |
|------|-----|------------|
| 1 | `{% extends "main/base.html" %}` | Этот шаблон расширяет base.html. Вся разметка берётся из base, здесь переопределяются только блоки. |
| 3–5 | `{% block title %}...{% endblock title %}` | Заголовок вкладки: если есть `category` — «Название — Каталог», иначе «Каталог». |
| 7–10 | Блок content, заголовок h1 | Заголовок страницы: либо название категории, либо «Все товары». |
| 12 | `{% if products %}` | Если view передал список товаров и он не пустой. |
| 13 | `<ul class="product-grid">` | Список-сетка (стили в base делают из него grid). |
| 14 | `{% for product in products %}` | Цикл по каждому товару. |
| 15–16 | Карточка и ссылка | Элемент списка с классом карточки. Ссылка на страницу товара: `{% url 'main:product_detail' id=product.id slug=product.slug %}`. |
| 17–22 | Фото | Если есть `product.image` — тег img с URL картинки. Иначе текст «Нет фото». |
| 23–26 | Название и цена | В блоке карточки: имя товара и цена в рублях. |
| 27–29 | Конец цикла и списка | `{% endfor %}`, `</ul>`. |
| 30–32 | Пустая корзина | Если товаров нет — сообщение «В этой категории пока нет товаров.» |
| 33–34 | Конец условия и блока | `{% endif %}`, `{% endblock content %}`. |

---

# 14. Шаблон details.html (страница товара)

| Стр. | Код | Объяснение |
|------|-----|------------|
| 1–6 | extends, block title | Расширение base, заголовок вкладки — название товара. |
| 8–14 | Фото товара | Блок с изображением: если есть — img, иначе «Нет фото». |
| 15–23 | Инфо и форма «В корзину» | Название (h1), цена, описание (или «Описание отсутствует»). Форма: method="post", action — URL добавления в корзину (`{% url 'cart_add' product_id=product.id %}`). Внутри: `{% csrf_token %}` (обязательно для POST), поле quantity (число 1–99), скрытое поле next с текущим URL (`{{ request.get_full_path }}`), кнопка «В корзину». При отправке формы вызывается cart_add; после редиректа пользователь остаётся на этой же странице (next). |
| 32–53 | Похожие товары | Если view передал `suggestedproducts` — заголовок и сетка карточек. В каждой — ссылка на товар, фото, название, цена. |

---

# 15. Шаблон cart.html (страница корзины)

| Стр. | Код | Объяснение |
|------|-----|------------|
| 1–3 | extends, block title | Расширение base, заголовок вкладки «Корзина». |
| 5–6 | Заголовок и условие | Заголовок «Корзина». Если в контексте передан объект `cart` и он не пустой (в Django непустой объект в условии if даёт True). |
| 8–18 | Таблица | Заголовки колонок: Товар, Цена, Кол-во, Сумма, пустая (для кнопки). |
| 20 | `{% for item in cart %}` | Цикл по корзине. Объект Cart итерируемый (метод __iter__); каждый item — словарь с product, quantity, price, total_price. |
| 22–24 | Название товара | Ссылка на страницу товара, текст — имя. |
| 25–26 | Цена и количество | Цена за единицу. В колонке «Кол-во» — форма обновления: action на cart_update с product_id, поле quantity, кнопка «Ок». При отправке вызывается cart_update. |
| 32–37 | Сумма и удаление | Итог по строке (total_price). Форма удаления: action на cart_remove, кнопка «Удалить». |
| 43 | Итого | `{{ cart.get_total_price }}` — вызов метода get_total_price (в шаблоне методы без аргументов вызываются автоматически). |
| 44–45 | Пустая корзина | Если корзины нет или она пустая — сообщение и ссылка в каталог. |

---

# Краткая схема работы

1. Пользователь открывает главную → main/urls → shop/urls → product_list → БД (категории, товары) → шаблон list.html с контекстом → HTML в браузер.
2. Клик по товару → product_detail → один товар + похожие → details.html. Форма «В корзину» → POST на cart_add → товар попадает в request.session['cart'] → редирект обратно.
3. Контекст-процессор при каждом запросе считает cart_count из сессии и передаёт в шаблоны — в шапке отображается «Корзина (N)».
4. Страница корзины: cart_detail → Cart(request) → в шаблоне цикл по cart (__iter__ подгружает товары из БД), таблица с обновлением количества и удалением. Формы отправляют POST на cart_update и cart_remove.

Если нужно разобрать ещё какой-то один файл или кусок кода построчно — напиши, какой именно.
